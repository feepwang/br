# 并查集 (Union-Find / Disjoint Set Union)

并查集是一种高效的数据结构，用于处理不相交集合的合并和查询操作。它在解决动态连通性问题时表现出色，能够在近乎常数时间内完成操作。

## 核心特性

### 1. 基本操作
- **Find(x)**: 查找元素 x 所属集合的代表元素（根节点）
- **Union(x, y)**: 合并包含元素 x 和 y 的两个集合
- **Connected(x, y)**: 判断元素 x 和 y 是否属于同一集合

### 2. 核心优化技术

#### 路径压缩 (Path Compression)
在执行 Find 操作时，将路径上的所有节点直接连接到根节点，大幅降低树的高度。

```go
func (uf *UnionFind) Find(x int) int {
    if uf.parent[x] != x {
        uf.parent[x] = uf.Find(uf.parent[x]) // 路径压缩
    }
    return uf.parent[x]
}
```

#### 按秩合并 (Union by Rank)
在合并两个集合时，总是将秩（近似深度）较小的树连接到秩较大的树根节点下，保持树的平衡。

```go
func (uf *UnionFind) Union(x, y int) {
    rootX, rootY := uf.Find(x), uf.Find(y)
    if rootX == rootY {
        return
    }
    
    if uf.rank[rootX] < uf.rank[rootY] {
        uf.parent[rootX] = rootY
    } else if uf.rank[rootX] > uf.rank[rootY] {
        uf.parent[rootY] = rootX
    } else {
        uf.parent[rootY] = rootX
        uf.rank[rootX]++
    }
}
```

### 3. 特殊之处

1. **近乎常数时间复杂度**: 使用路径压缩和按秩合并后，操作的平均时间复杂度为 O(α(n))，其中 α 是反阿克曼函数，在实际应用中可视为常数。

2. **极简的实现**: 相比其他高级数据结构（如红黑树、AVL树），并查集的实现极其简洁。

3. **空间效率**: 只需要两个数组（parent 和 rank），空间复杂度为 O(n)。

4. **渐进最优**: 已被证明在某些问题上达到了理论下界。

## 接口设计

### 基础接口
```go
type Interface interface {
    Union(x, y int)              // 合并两个元素所在的集合
    Find(x int) int              // 查找元素的根节点
    Connected(x, y int) bool     // 判断两个元素是否连通
    Count() int                  // 返回集合数量
    Size() int                   // 返回元素总数
    SetSize(x int) int           // 返回包含元素 x 的集合大小
    Sets() [][]int               // 返回所有集合
    Reset(size int)              // 重置为指定大小
}
```

### Go 1.23+ 迭代器支持
```go
// 额外的迭代器方法
AllSets() iter.Seq[[]int]           // 迭代所有集合
SetMembers(x int) iter.Seq[int]     // 迭代指定集合的所有成员
```

## 使用示例

### 基本用法
```go
package main

import (
    "fmt"
    "github.com/feepwang/br/container/union_find"
)

func main() {
    // 创建包含 10 个元素的并查集
    uf := union_find.NewUnionFind(10)
    
    // 合并一些元素
    uf.Union(0, 1)
    uf.Union(1, 2)
    uf.Union(3, 4)
    
    // 检查连通性
    fmt.Println(uf.Connected(0, 2)) // true
    fmt.Println(uf.Connected(0, 3)) // false
    
    // 获取集合信息
    fmt.Println("集合数量:", uf.Count())        // 8
    fmt.Println("集合 {0,1,2} 的大小:", uf.SetSize(0)) // 3
    
    // 获取所有集合
    sets := uf.Sets()
    fmt.Println("所有集合:", sets)
    // 输出: [[0 1 2] [3 4] [5] [6] [7] [8] [9]]
}
```

### 网络连通性检测
```go
func checkNetworkConnectivity(n int, connections [][2]int) bool {
    uf := union_find.NewUnionFind(n)
    
    // 建立连接
    for _, conn := range connections {
        uf.Union(conn[0], conn[1])
    }
    
    // 检查是否所有节点都连通（只有一个集合）
    return uf.Count() == 1
}
```

### Go 1.23+ 迭代器示例
```go
// 遍历所有集合
for set := range uf.AllSets() {
    fmt.Printf("集合: %v, 大小: %d\n", set, len(set))
}

// 遍历特定集合的成员
fmt.Print("集合成员: ")
for member := range uf.SetMembers(0) {
    fmt.Printf("%d ", member)
}
fmt.Println()
```

## 工业应用场景

### 1. 网络连通性分析
- **计算机网络**: 检测网络中节点间的连通性，网络分区检测
- **社交网络**: 发现社交圈子，推荐好友，社区检测
- **互联网基础设施**: 路由表优化，网络拓扑分析

### 2. 图像处理
- **连通组件标记**: 在二值图像中标记连通的像素区域
- **图像分割**: 将图像分割成不同的区域
- **形态学操作**: 腐蚀、膨胀等操作的高效实现

### 3. 算法优化
- **最小生成树**: Kruskal 算法的核心组件
- **拓扑排序**: 检测有向图中的环
- **动态连通性**: 在线处理边的增删操作

### 4. 数据库系统
- **查询优化**: 连接操作的优化
- **分布式系统**: 数据分片和负载均衡
- **事务处理**: 死锁检测

### 5. 机器学习
- **聚类算法**: 基于连通性的聚类方法
- **特征选择**: 相关特征的分组
- **决策树**: 构建决策边界

### 6. 游戏开发
- **地图生成**: 检查地图的连通性
- **AI 寻路**: 区域划分和路径规划
- **物理引擎**: 碰撞检测优化

### 7. 生物信息学
- **蛋白质结构**: 分析蛋白质的结构域
- **基因网络**: 研究基因间的相互作用
- **系统发育**: 构建进化树

### 8. 金融科技
- **风险评估**: 关联账户检测，反欺诈
- **交易网络**: 分析资金流向和交易模式
- **信用评估**: 基于社交网络的信用建模

## 性能分析

| 操作 | 时间复杂度 | 说明 |
|------|------------|------|
| Find | O(α(n)) | α 是反阿克曼函数，实际应用中近似为常数 |
| Union | O(α(n)) | 包含两次 Find 操作 |
| Connected | O(α(n)) | 等价于比较两次 Find 的结果 |
| Count | O(1) | 维护一个计数器 |
| SetSize | O(n) | 需要遍历所有元素 |
| Sets | O(n) | 需要遍历所有元素并分组 |

**空间复杂度**: O(n)

## 实现细节

### 数据结构
```go
type UnionFind struct {
    parent []int // parent[i] 表示元素 i 的父节点
    rank   []int // rank[i] 表示以 i 为根的树的近似深度
    count  int   // 当前集合数量
    size   int   // 元素总数
}
```

### 关键优化
1. **路径压缩**: 在 Find 操作中将访问路径上的所有节点直接连接到根节点
2. **按秩合并**: 总是将较小的树连接到较大的树下
3. **延迟更新**: rank 数组不严格维护树的深度，而是作为启发式信息

## 与其他数据结构的比较

| 数据结构 | 查找 | 插入 | 删除 | 空间 | 实现复杂度 |
|----------|------|------|------|------|------------|
| 并查集 | O(α(n)) | - | - | O(n) | 极简 |
| 哈希表 | O(1) | O(1) | O(1) | O(n) | 中等 |
| 平衡树 | O(log n) | O(log n) | O(log n) | O(n) | 复杂 |
| 图的邻接表 | O(V+E) | O(1) | O(V) | O(V+E) | 简单 |

**注意**: 并查集专门解决动态连通性问题，不支持删除操作。

## 理论基础

### 反阿克曼函数
反阿克曼函数 α(n) 增长极其缓慢：
- α(2^16) = 3
- α(2^65536) = 4
- α(2^2^65536) = 5

在实际应用中，α(n) ≤ 5，因此可以视为常数。

### 渐进最优性
已证明在某些模型下，任何解决动态连通性问题的数据结构的下界为 Ω(α(n))，因此并查集在渐进意义下是最优的。

## 变种和扩展

### 1. 支持删除的并查集
通过重构技术或版本化方法支持删除操作。

### 2. 持久化并查集
支持历史版本查询的并查集实现。

### 3. 在线最小生成树
结合并查集实现动态图的最小生成树维护。

### 4. 加权并查集
在合并时考虑权重信息，用于解决更复杂的问题。

## 适用场景总结

并查集特别适合以下场景：
1. **动态连通性查询**: 需要频繁查询两个元素是否连通
2. **集合合并操作**: 需要高效地合并两个集合
3. **无需删除**: 不需要从集合中删除元素
4. **静态或增量式**: 数据以静态或只增加的方式更新
5. **简单实现**: 对实现复杂度有要求的场景

并查集以其简洁的实现和优异的性能，成为了解决特定类型问题的经典选择，在现代计算机科学和工业应用中发挥着重要作用。